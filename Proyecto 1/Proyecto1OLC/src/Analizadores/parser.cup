package Analizadores;
import java_cup.runtime.Symbol;
import Errores.*;
import Instrucciones.*;
import AST.*;


parser code 
{:

    public String resultado = "";
    public int cont = 1;

    /*Method that is called when parser can be recovered*/
    public void syntax_error(Symbol s){ 
        //System.out.println("Unexpected token: " +s.value);
        //System.out.println("Error sintactico en la linea " + (s.right + 1) + " column " + (s.left + 1));
        Instruction.list.addError(new Error_("Error sintactico: " + s.value, "Sintactico", s.right + 1, s.left + 1));
    }

    /*Method that is called when parser can't be recovered*/
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        //System.out.println("Error sintactico unrecovered: " + s.value);
        //System.out.println("Error sintactico unrecovered en la linea " + s.right + " column " + s.left);
        Instruction.list.addError(new Error_("Error sintactico unrecovered: " + s.value, "Sintactico", s.right + 1, s.left + 1));
    } 
:}


terminal String tnum;
terminal String tletras;
terminal tpcoma, tunder;
terminal tinicio, tfin;
terminal tint, tstring, tbool, tchar;
terminal trest,tsum,tdiv,tmul,tpot,tmod, tparA, tparC, tcorA, tcorC;
terminal tmayor, tmenor, tmayor_igual, tmenor_igual, tes_igual, tdifer;
terminal tor, tand, tnot;
terminal tingresar, tcomo, tcon_val, tcoma, tvar_name, tarrow;
terminal tif, tthen, tendif, telse, telseif;
terminal tcadena, tboolean, tcaracter;
terminal tsegun, tdo, tfin_segun, tQn_A, tQn_C;
terminal tfor, thasta, tfin_for, tincrease;
terminal twhile, tend_while;
terminal trepeat, tuntil;
terminal treturn;
terminal tmetodo, tfin_metodo, tparams;
terminal tfuncion, tfin_funcion;
terminal texec, tprint, tprintln;

non terminal S;
non terminal INSTRUCTIONS, INSTRUCTION;
non terminal STATEMENT, VAR, DATATYPE;
non terminal ASSIGNMENT;
non terminal EXPRESSION;
non terminal CONDITIONAL, CONDITIONALS, CONDITION, REL, OP_REL;
non terminal SWITCH, VALOR, CASE, DEFAULT, C, OPC;
non terminal FOR, INCREASE, INSTRUCCIONES;
non terminal WHILE;
non terminal REPETIR;
non terminal RETURN;
non terminal METODO, PARAMS, LISTPARAMS;
non terminal FUNCION;
non terminal EXEC, PARAMETROS;
non terminal PRINT;
non terminal INIT;

precedence left tcoma;

precedence left tmayor, tmenor, tmayor_igual, tmenor_igual;
precedence left tes_igual, tdifer;

precedence left tand, tor;
precedence right tnot;
precedence left tsum, trest;
precedence left tdiv, tmul;
precedence left tmod, tpot;
precedence left tparA, tparC;
precedence left tcorA, tcorC;



start with S;

S ::= tinicio INSTRUCTIONS:s tfin {:
        Nodo n = new Nodo("tinicio");
        Nodo n2 = new Nodo("tfin");
        n.setValor("inicio");
        n.setIdNodo(parser.cont++);
        n2.setValor("fin");
        n2.setIdNodo(parser.cont++);
        Instruction.ast.addHijo(n);
        Instruction.ast.addHijo((Nodo) s);
        Instruction.ast.addHijo(n2);
        Instruction.ast.setIdNodo(parser.cont++);
    :}
    | tinicio tfin
    | error
;

INSTRUCTIONS ::= INSTRUCTIONS:ins1 INSTRUCTION:ins2 {: 
        Nodo n = new Nodo("Instrucciones");
        n.addHijo((Nodo) ins1);
        n.addHijo((Nodo) ins2);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | INSTRUCTION:ins {:
        RESULT = ins;
    :}
;

INSTRUCTION ::= STATEMENT:s tpcoma {:
        Nodo n = new Nodo("Instruccion");
        Nodo n2 = new Nodo("tpcoma");
        n2.setValor(";");
        n2.setIdNodo(parser.cont++);
        Nodo aux = (Nodo) s;
        aux.addHijo(n2);
        n.addHijo((Nodo) aux);
        n.setIdNodo(parser.cont++);
        RESULT = n;

    :}
    | STATEMENT:a {: Instruction.list.addError(new Error_("Falta un: \";\"", "Sintactico", aright, -1)); :}
    | ASSIGNMENT:s tpcoma {:
        Nodo n = new Nodo("Instruccion");
        Nodo n2 = new Nodo("tpcoma");
        n2.setValor(";");
        n2.setIdNodo(parser.cont++);
        Nodo aux = (Nodo) s;
        aux.addHijo(n2);
        n.addHijo((Nodo) aux);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | ASSIGNMENT:a {: Instruction.list.addError(new Error_("Falta un: \";\"", "Sintactico", aright, -1)); :}
    | CONDITIONAL:s tendif:a {:
        Nodo n = new Nodo("Instruccion");
        Nodo n2 = new Nodo("tendif");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        Nodo aux = (Nodo) s;
        aux.addHijo(n2);
        n.addHijo((Nodo) aux);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | SWITCH:s tfin_segun:a {:
        Nodo n = new Nodo("Instruccion");
        Nodo n2 = new Nodo("tfin_segun");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        Nodo aux = (Nodo) s;
        aux.addHijo(n2);
        n.addHijo((Nodo) aux);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | FOR:s tfin_for:a {:
        Nodo n = new Nodo("Instruccion");
        Nodo n2 = new Nodo("tfin_segun");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        Nodo aux = (Nodo) s;
        aux.addHijo(n2);
        n.addHijo((Nodo) aux);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | WHILE:s tend_while:a {:
        Nodo n = new Nodo("Instruccion");
        Nodo n2 = new Nodo("tend_while");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        Nodo aux = (Nodo) s;
        aux.addHijo(n2);
        n.addHijo((Nodo) aux);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | REPETIR:s {:
        Nodo n = new Nodo("Instruccion");
        n.addHijo((Nodo) s);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | METODO:s tfin_metodo:a {:
        Nodo n = new Nodo("Instruccion");
        Nodo n2 = new Nodo("tfin_metodo");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        Nodo aux = (Nodo) s;
        aux.addHijo(n2);
        n.addHijo((Nodo) aux);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | FUNCION:s tfin_funcion:a {:
        Nodo n = new Nodo("Instruccion");
        Nodo n2 = new Nodo("tfin_funcion");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        Nodo aux = (Nodo) s;
        aux.addHijo(n2);
        n.addHijo((Nodo) aux);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXEC:s tpcoma:a {:
        Nodo n = new Nodo("Instruccion");
        Nodo n2 = new Nodo("tpcoma");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        Nodo aux = (Nodo) s;
        aux.addHijo(n2);
        n.addHijo((Nodo) aux);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | PRINT:s tpcoma:a {:
        Nodo n = new Nodo("Instruccion");
        Nodo n2 = new Nodo("tpcoma");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        Nodo aux = (Nodo) s;
        aux.addHijo(n2);
        n.addHijo((Nodo) aux);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | error tpcoma
    | error tendif
    | error tfin_segun
    | error tfin_for
    | error tend_while
    | error tfin_metodo
    | error tfin_funcion
;

STATEMENT ::= tingresar VAR:v tcomo DATATYPE:d tcon_val REL:r {:
        Nodo n = new Nodo("Declaracion");
        Nodo n2 = new Nodo("ingresar");
        n2.setValor("ingresar");
        n2.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) v);
        n.addHijo((Nodo) d);
        n.addHijo((Nodo) r);
        n.setIdNodo(parser.cont++);
        RESULT =  n;
    :}
;

VAR ::= VAR:a tcoma VAR:b {:
        Nodo n = new Nodo("Var");
        Nodo n2 = new Nodo("coma");
        n2.setValor(";");
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT =  n;
    :}
    | tvar_name:a {:
        Nodo aux = new Nodo("id");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
;

DATATYPE ::= tint:a {:
        Nodo aux = new Nodo("type");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tstring:a {:
        Nodo aux = new Nodo("type");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tbool:a {:
        Nodo aux = new Nodo("type");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tchar:a {:
        Nodo aux = new Nodo("type");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
;

ASSIGNMENT ::= VAR:a tarrow:x REL:b {:
        Nodo n = new Nodo("Asignacion");
        Nodo n2 = new Nodo("tarrow");
        n2.setValor(x.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
;


CONDITIONAL ::= tif:a CONDITION:b tthen:c INSTRUCTIONS:d {:
        Nodo n = new Nodo("Condicional");
        Nodo n2 = new Nodo("tif");
        Nodo n3 = new Nodo("tthen");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        n3.setValor(c.toString());
        n3.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.addHijo(n3);
        n.addHijo((Nodo) d);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | tif:a CONDITION:b tthen:c INSTRUCTIONS:d telse:e INSTRUCTIONS:f {:    
        Nodo n = new Nodo("Condicional");
        Nodo n2 = new Nodo("tif");
        Nodo n3 = new Nodo("tthen");
        Nodo n4 = new Nodo("telse");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        n3.setValor(c.toString());
        n3.setIdNodo(parser.cont++);
        n4.setValor(e.toString());
        n4.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.addHijo(n3);
        n.addHijo((Nodo) d);
        n.addHijo(n4);
        n.addHijo((Nodo) f);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | tif:a CONDITION:b CONDITIONALS:c {:
        Nodo n = new Nodo("Condicional");
        Nodo n2 = new Nodo("tif");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.addHijo((Nodo) c);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
;

CONDITIONALS ::= CONDITIONALS:a telseif:b CONDITION:c tthen:d INSTRUCTIONS:e {:
        Nodo n = new Nodo("Condicionales");
        Nodo n2 = new Nodo("telseif");
        Nodo n3 = new Nodo("tthen");
        n2.setValor(b.toString());
        n2.setIdNodo(parser.cont++);
        n3.setValor(d.toString());
        n3.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) c);
        n.addHijo(n3);
        n.addHijo((Nodo) e);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | telse:a INSTRUCTIONS:b {:
        Nodo n = new Nodo("Condicionales");
        Nodo n2 = new Nodo("telse");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
;

CONDITION ::= CONDITION:a tor:b CONDITION:c {:
        Nodo n = new Nodo("Condicion");
        Nodo n2 = new Nodo("tor");
        n2.setValor(b.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) c);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | CONDITION:a tand:b CONDITION:c {:
        Nodo n = new Nodo("Condicion");
        Nodo n2 = new Nodo("tand");
        n2.setValor(b.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) c);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | tnot:a CONDITION:b {:
        Nodo n = new Nodo("Condicion");
        Nodo n2 = new Nodo("tnot");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | tparA:a CONDITION:b tparC:c {:
        Nodo n = new Nodo("Condicion");
        Nodo n2 = new Nodo("tparA");
        Nodo n3 = new Nodo("tparC");
        n2.setValor(a.toString());
        n2.setIdNodo(parser.cont++);
        n2.setValor(c.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.addHijo(n3);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | REL:n {:
        RESULT = n;
    :}
;

REL ::= EXPRESSION:a OP_REL:c EXPRESSION:b {:
        Nodo n = new Nodo("Rel");
        n.addHijo((Nodo) a);
        n.addHijo((Nodo) c);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a {:
        RESULT = a;
    :}
;

OP_REL ::= tmayor:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tmenor:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tmayor_igual:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tmenor_igual:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tes_igual:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tdifer:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
;

EXPRESSION ::= trest:s EXPRESSION:a {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) a);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a tsum:s EXPRESSION:b {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a trest:s EXPRESSION:b {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a tdiv:s EXPRESSION:b {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a tmul:s EXPRESSION:b {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a tpot:s tcorA:c EXPRESSION:b tcorC:d {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("tpot");
        Nodo n3 = new Nodo("tcorA");
        Nodo n4 = new Nodo("tcorC");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n3.setValor(c.toString());
        n3.setIdNodo(parser.cont++);
        n4.setValor(d.toString());
        n4.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo(n3);
        n.addHijo((Nodo) b);
        n.addHijo(n4);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a tmod:s EXPRESSION:b {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | tparA:s1 EXPRESSION:a tparC:s2 {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Parentesis");
        Nodo n3 = new Nodo("Parentesis");
        n2.setValor(s1.toString());
        n2.setIdNodo(parser.cont++);
        n3.setValor(s2.toString());
        n3.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) a);
        n.addHijo(n3);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | tvar_name:a {:
        Nodo aux = new Nodo("tvar_name");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tnum:a {:
        Nodo aux = new Nodo("tnum");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tcadena:a {:
        Nodo aux = new Nodo("tcadena");
        aux.setValor(a.toString().replaceAll("\"", ""));
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tboolean:a {:
        Nodo aux = new Nodo("tboolean");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tcaracter:a {:
        Nodo aux = new Nodo("tcaracter");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}       
;

SWITCH ::= tsegun EXPRESSION tdo CASE DEFAULT;

CASE ::= CASE C
    | C
;

C ::= tQn_A OPC tQn_C tthen INSTRUCTIONS;

OPC ::= tnum
    | tcaracter
    | tcadena
;

DEFAULT ::= telse tthen INSTRUCTIONS
    | //empty
;

FOR ::= tfor tvar_name tarrow VALOR thasta VALOR INCREASE tdo INSTRUCTIONS
    | tfor tvar_name tarrow VALOR thasta VALOR INCREASE INSTRUCTIONS
;

INCREASE ::= tincrease EXPRESSION
    | //empty
;

INSTRUCCIONES ::= INSTRUCTIONS
    | //empty
;

WHILE ::= twhile CONDITION tdo INSTRUCCIONES;

REPETIR ::= trepeat INSTRUCCIONES tuntil CONDITION;

RETURN ::= treturn CONDITION tpcoma;

METODO ::= tmetodo tvar_name PARAMS INSTRUCTIONS;

PARAMS ::= tparams tparA LISTPARAMS tparC
    | //empty
;

LISTPARAMS ::= LISTPARAMS tcoma LISTPARAMS
    | tvar_name DATATYPE
;

FUNCION ::= tfuncion tvar_name DATATYPE PARAMS INSTRUCTIONS RETURN;

EXEC ::= texec tvar_name tparA PARAMETROS tparC;

PARAMETROS ::= PARAMETROS tcoma PARAMETROS 
    | EXPRESSION
    | //empty
;

PRINT ::= tprint REL
    | tprint EXEC
    | tprintln REL
    | tprintln EXEC
;