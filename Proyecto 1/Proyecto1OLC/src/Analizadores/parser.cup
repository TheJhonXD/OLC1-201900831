package Analizadores;
import java_cup.runtime.Symbol;
import Errores.*;
import Instrucciones.*;
import AST.*;


parser code 
{:

    public String resultado = "";
    public Nodo padre;
    public int cont = 1;

    /*Method that is called when parser can be recovered*/
    public void syntax_error(Symbol s){ 
        //System.out.println("Unexpected token: " +s.value);
        //System.out.println("Error sintactico en la linea " + (s.right + 1) + " column " + (s.left + 1));
        Instruction.list.addError(new Error_("Unexpected token: " + s.value, "Sintactico", s.right + 1, s.left + 1));
    }

    /*Method that is called when parser can't be recovered*/
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        //System.out.println("Error sintactico unrecovered: " + s.value);
        //System.out.println("Error sintactico unrecovered en la linea " + s.right + " column " + s.left);
        Instruction.list.addError(new Error_("Error sintactico unrecovered: " + s.value, "Sintactico", s.right + 1, s.left + 1));
    } 
:}


terminal String tnum;
terminal String tletras;
terminal tpcoma, tunder;
terminal tinicio, tfin;
terminal tint, tstring, tbool, tchar;
terminal trest,tsum,tdiv,tmul,tpot,tmod, tparA, tparC, tcorA, tcorC;
terminal tmayor, tmenor, tmayor_igual, tmenor_igual, tes_igual, tdifer;
terminal tor, tand, tnot;
terminal tingresar, tcomo, tcon_val, tcoma, tvar_name, tarrow;
terminal tif, tthen, tendif, telse, telseif;
terminal tcadena, tboolean, tcaracter;
terminal tsegun, tdo, tfin_segun, tQn_A, tQn_C;
terminal tfor, thasta, tfin_for, tincrease;
terminal twhile, tend_while;
terminal trepeat, tuntil;
terminal treturn;
terminal tmetodo, tfin_metodo, tparams;
terminal tfuncion, tfin_funcion;
terminal texec, tprint, tprintln;

non terminal S;
non terminal INSTRUCTIONS, INSTRUCTION;
non terminal STATEMENT, VAR, DATATYPE;
non terminal ASSIGNMENT;
non terminal EXPRESSION;
non terminal CONDITIONAL, CONDITIONALS, CONDITION, REL, OP_REL;
non terminal SWITCH, VALOR, CASE, DEFAULT, C, OPC;
non terminal FOR, INCREASE, INSTRUCCIONES;
non terminal WHILE;
non terminal REPETIR;
non terminal RETURN;
non terminal METODO, PARAMS, LISTPARAMS;
non terminal FUNCION;
non terminal EXEC, PARAMETROS;
non terminal PRINT;
non terminal INIT;

precedence left tcoma;

precedence left tmayor, tmenor, tmayor_igual, tmenor_igual;
precedence left tes_igual, tdifer;

precedence left tand, tor;
precedence right tnot;
precedence left tsum, trest;
precedence left tdiv, tmul;
precedence left tmod, tpot;
precedence left tparA, tparC;
precedence left tcorA, tcorC;



start with S;

S ::= tinicio INSTRUCTIONS:s tfin {: 
        Nodo n = new Nodo("inicio");
        n.addHijo((Nodo) s);
        n.setIdNodo(parser.cont++);
        parser.padre = n;
        RESULT = n;
    :}
    | tinicio tfin
    | error
;

INSTRUCTIONS ::= INSTRUCTIONS:ins1 INSTRUCTION:ins2 {: 
        Nodo n = new Nodo("Instrucciones");
        n.addHijo((Nodo) ins1);
        n.addHijo((Nodo) ins2);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | INSTRUCTION:ins {:
        RESULT = ins;
    :}
;

INSTRUCTION ::= STATEMENT:s tpcoma {:
        Nodo n = new Nodo("Instruccion");
        n.addHijo((Nodo) s);
        n.setIdNodo(parser.cont++);
        RESULT = n;

    :}
    | STATEMENT:a {: Instruction.list.addError(new Error_("Falta un: \";\"", "Sintactico", aright, -1)); :}
    | ASSIGNMENT tpcoma
    | ASSIGNMENT:a {: Instruction.list.addError(new Error_("Falta un: \";\"", "Sintactico", aright, -1)); :}
    | CONDITIONAL tendif
    | SWITCH tfin_segun
    | FOR tfin_for
    | WHILE tend_while
    | REPETIR
    | METODO tfin_metodo
    | FUNCION tfin_funcion
    | EXEC tpcoma
    | PRINT tpcoma
    | error tpcoma
    | error tendif
    | error tfin_segun
    | error tfin_for
    | error tend_while
    | error tfin_metodo
    | error tfin_funcion
;

STATEMENT ::= tingresar VAR:v tcomo DATATYPE:d tcon_val REL:r {:
        Nodo n = new Nodo("Declaracion");
        Nodo n2 = new Nodo("ingresar");
        n2.setValor("ingresar");
        n2.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) v);
        n.addHijo((Nodo) d);
        n.addHijo((Nodo) r);
        n.setIdNodo(parser.cont++);
        RESULT =  n;
    :}
;

VAR ::= VAR:a tcoma VAR:b {:
        Nodo n = new Nodo("Var");
        Nodo n2 = new Nodo("coma");
        n2.setValor(";");
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT =  n;
    :}
    | tvar_name:a {:
        Nodo aux = new Nodo("id");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
;

DATATYPE ::= tint:a {:
        Nodo aux = new Nodo("type");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tstring:a {:
        Nodo aux = new Nodo("type");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tbool:a {:
        Nodo aux = new Nodo("type");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tchar:a {:
        Nodo aux = new Nodo("type");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
;

ASSIGNMENT ::= VAR tarrow REL;


CONDITIONAL ::= tif CONDITION tthen INSTRUCTIONS
    | tif CONDITION INSTRUCTIONS telse INSTRUCTIONS
    | tif CONDITION CONDITIONALS
;

CONDITIONALS ::= CONDITIONALS telseif CONDITION tthen INSTRUCTIONS
    | telse INSTRUCTIONS
;

CONDITION ::= CONDITION tor CONDITION
    | CONDITION tand CONDITION
    | tnot CONDITION
    | tparA CONDITION tparC
    | REL
;

REL ::= EXPRESSION:a OP_REL:c EXPRESSION:b {:
        Nodo n = new Nodo("Rel");
        n.addHijo((Nodo) a);
        n.addHijo((Nodo) c);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a {:
        RESULT = a;
    :}
;

OP_REL ::= tmayor:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tmenor:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tmayor_igual:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tmenor_igual:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tes_igual:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tdifer:a {:
        Nodo aux = new Nodo("Op Relacional");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
;

EXPRESSION ::= trest:s EXPRESSION:a {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) a);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a tsum:s EXPRESSION:b {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a trest:s EXPRESSION:b {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a tdiv:s EXPRESSION:b {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a tmul:s EXPRESSION:b {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a tpot:s tcorA EXPRESSION:b tcorC {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | EXPRESSION:a tmod:s EXPRESSION:b {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Operador");
        n2.setValor(s.toString());
        n2.setIdNodo(parser.cont++);
        n.addHijo((Nodo) a);
        n.addHijo(n2);
        n.addHijo((Nodo) b);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | tparA:s1 EXPRESSION:a tparC:s2 {:
        Nodo n = new Nodo("Expresion");
        Nodo n2 = new Nodo("Parentesis");
        Nodo n3 = new Nodo("Parentesis");
        n2.setValor(s1.toString());
        n2.setIdNodo(parser.cont++);
        n3.setValor(s2.toString());
        n3.setIdNodo(parser.cont++);
        n.addHijo(n2);
        n.addHijo((Nodo) a);
        n.addHijo(n3);
        n.setIdNodo(parser.cont++);
        RESULT = n;
    :}
    | tvar_name:a {:
        Nodo aux = new Nodo("Expresion");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tnum:a {:
        Nodo aux = new Nodo("Expresion");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tcadena:a {:
        Nodo aux = new Nodo("Expresion");
        aux.setValor(a.toString().replaceAll("\"", ""));
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tboolean:a {:
        Nodo aux = new Nodo("Expresion");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}
    | tcaracter:a {:
        Nodo aux = new Nodo("Expresion");
        aux.setValor(a.toString());
        aux.setIdNodo(parser.cont++);
        RESULT = aux;
    :}       
;

SWITCH ::= tsegun EXPRESSION tdo CASE DEFAULT;

CASE ::= CASE C
    | C
;

C ::= tQn_A OPC tQn_C tthen INSTRUCTIONS;

OPC ::= tnum
    | tcaracter
    | tcadena
;

DEFAULT ::= telse tthen INSTRUCTIONS
    | //empty
;

FOR ::= tfor tvar_name tarrow VALOR thasta VALOR INCREASE tdo INSTRUCTIONS
    | tfor tvar_name tarrow VALOR thasta VALOR INCREASE INSTRUCTIONS
;

INCREASE ::= tincrease EXPRESSION
    | //empty
;

INSTRUCCIONES ::= INSTRUCTIONS
    | //empty
;

WHILE ::= twhile CONDITION tdo INSTRUCCIONES;

REPETIR ::= trepeat INSTRUCCIONES tuntil CONDITION;

RETURN ::= treturn CONDITION tpcoma;

METODO ::= tmetodo tvar_name PARAMS INSTRUCTIONS;

PARAMS ::= tparams tparA LISTPARAMS tparC
    | //empty
;

LISTPARAMS ::= LISTPARAMS tcoma LISTPARAMS
    | tvar_name DATATYPE
;

FUNCION ::= tfuncion tvar_name DATATYPE PARAMS INSTRUCTIONS RETURN;

EXEC ::= texec tvar_name tparA PARAMETROS tparC;

PARAMETROS ::= PARAMETROS tcoma PARAMETROS 
    | EXPRESSION
    | //empty
;

PRINT ::= tprint REL
    | tprint EXEC
    | tprintln REL
    | tprintln EXEC
;